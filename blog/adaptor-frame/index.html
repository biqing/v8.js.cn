<!doctype html><html lang=zh-CN><meta charset=utf-8><title>更快的 JavaScript 调用 · V8</title><meta content="width=device-width" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=" js"</script><meta content="通过删除参数 adaptor frame 来加快 JavaScript 调用" name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/tools/ >工具</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>更快的 JavaScript 调用</h1><p class=meta>发布时间 <time datetime="2021-02-15 00:00:00" itemprop=datePublished title="2021-02-15 00:00:00">2021-02-15</time> · 标签： <a href=/blog/tags/internals/ class=tag>internals</a></header><div itemprop=articleBody><p>JavaScript 允许使用与预期的参数数量不同的参数数量来调用函数，即，与所声明的形式参数相比，可以传递更少或更多的参数。前者称为 under-application，后者称为 over-application。<p>在 under-application 的情况下，将为其余参数分配未定义（undefined）的值。在 over-application 的情况下，可以使用剩余（rest）参数和 <code>arguments</code> 属性访问其余参数，或者它们只是多余的，可以忽略。如今，许多 Web/Node.js 框架都使用此 JS 特性来接受可选参数并创建更灵活的 API。<p>直到最近，V8 都有一种特殊的机制来处理参数大小不匹配的情况：arguments adaptor frame。不幸的是，参数自适应（argument adaption）是以性能为代价的，但是在现代的前端和中间件框架中通常是必需的。事实证明，通过一个巧妙的技巧，我们可以删除此多余的帧（frame），简化 V8 代码库，并消除几乎所有的开销。<p>我们可以通过微基准测试（micro-benchmark）计算删除 arguments adaptor frame 对性能的影响。<pre class=language-js><code class=language-js>console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><br><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>  <span class="token constant">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br>console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><figure><img alt="" height=371 loading=lazy src=/_img/v8-release-89/perf.svg width=600><figcaption>通过微基准测试，测量删除 arguments adaptor frame 的性能影响。</figcaption></figure><p>该图显示，在 <a href=https://v8.dev/blog/jitless>JIT-less 模式</a>（Ignition）下运行时，不再有开销，并且性能提高了 11.2％。使用 <a href=https://v8.dev/docs/turbofan>TurboFan</a> 时，我们的速度提高了 40％。<p>这个微基准测试自然是为了最大程度地提高 arguments adaptor frame 的影响而设计的。但是，我们已经看到许多基准测试都有相当大的改进，例如<a href=https://chromium.googlesource.com/v8/v8/+/b7aa85fe00c521a704ca83cc8789354e86482a60/test/js-perf-test/JSTests.json>我们的 内部 JSTests/Array 基准测试</a>（7％）和 <a href=https://github.com/chromium/octane>Octane2</a>（Richards 为 4.6％，EarleyBoyer 为 6.1％）中。<h2 id=tl;dr:-reverse-the-arguments>TL;DR: 颠倒参数顺序 <a href=#tl;dr:-reverse-the-arguments class=bookmark>#</a></h2><p>该项目的重点是删除 arguments adaptor frame，该帧为被调用者（callee）在访问堆栈中的参数时提供了一致的接口。为此，我们需要颠倒堆栈中的参数顺序，并在被调用者帧（callee frame）中添加一个包含实际参数数量的新插槽（slot）。下图显示了更改前后的典型帧（typical frame）示例。<figure><img alt="" height=624 loading=lazy src=/_img/adaptor-frame/frame-diff.svg width=639><figcaption>删除 arguments adaptor frame 之前和之后的典型 JavaScript 栈帧（stack frame）。</figcaption></figure><h2 id=making-javascript-calls-faster>使 JavaScript 调用更快 <a href=#making-javascript-calls-faster class=bookmark>#</a></h2><p>为了理解为加快调用速度所做的工作，我们来看看 V8 如何执行调用以及 arguments adaptor frame 如何工作。<p>当我们在 JS 中执行函数调用时，在 V8 内部会发生什么？让我们假设有以下 JS 脚本：<pre class=language-js><code class=language-js><span class="token keyword">function</span> <span class="token function">add42</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">42</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><span class="token function">add42</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><figure><img alt="" height=391 loading=lazy src=/_img/adaptor-frame/flow.svg width=1193><figcaption>V8 内部在函数调用期间的执行流程。</figcaption></figure><h2 id=ignition>Ignition <a href=#ignition class=bookmark>#</a></h2><p>V8 是多层 VM。它的第一层称为 <a href=https://v8.dev/docs/ignition>Ignition</a>，它是一个带有累加器寄存器（register）的字节码（bytecode）堆栈机。V8 首先将代码编译为 <a href=https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775>Ignition 字节码</a>。上面的调用被编译为以下内容：<pre><code>0d              LdaUndefined              ;; Load undefined into the accumulator
26 f9           Star r2                   ;; Store it in register r2
13 01 00        LdaGlobal [1]             ;; Load global pointed by const 1 (add42)
26 fa           Star r1                   ;; Store it in register r1
0c 03           LdaSmi [3]                ;; Load small integer 3 into the accumulator
26 f8           Star r3                   ;; Store it in register r3
5f fa f9 02     CallNoFeedback r1, r2-r3  ;; Invoke call
</code></pre><p>调用的第一个参数通常称为接收者（receiver）。接收者是 JS 函数（JSFunction）中的 <code>this</code> 对象，并且每个 JS 函数调用都必须有一个。<code>CallNoFeedback</code> 的字节码处理程序需要使用寄存器列表 <code>r2-r3</code> 中的参数调用对象 <code>r1</code>。<p>在深入字节码处理程序之前，请注意寄存器是如何在字节码中编码的。它们是负的单字节整数：<code>r1</code> 编码为 <code>fa</code>，<code>r2</code> 编码为 <code>f9</code>，<code>r3</code> 编码为 <code>f8</code>。我们可以将任何寄存器 ri 称为 <code>fb - i</code>，实际上，正如我们将看到的，正确的编码是 <code>- 2 - kFixedFrameHeaderSize - i</code>。寄存器列表使用第一个寄存器和列表的大小进行编码，因此 <code>r2-r3</code> 为 <code>f9 02</code>。<p>Ignition 中有许多字节码调用处理程序。你可以在<a href="https://source.chromium.org/chromium/chromium/src/+/master:v8/src/interpreter/bytecodes.h;drc=3965dcd5cb1141c90f32706ac7c965dc5c1c55b3;l=184">此处</a>查看它们的列表。它们彼此之间略有不同。对于使用 <code>undefined</code> 的接收者的调用，对于属性调用，对于具有固定数量的参数的调用或对于通用调用，存在优化的字节码。在这里，我们分析 <code>CallNoFeedback</code>，这是一个通用调用，在该调用中，我们不累加执行过程中的反馈。<p>该字节码的处理程序非常简单。它是用 <a href=https://v8.dev/docs/csa-builtins><code>CodeStubAssembler</code></a> 编写的，你可以在<a href="https://source.chromium.org/chromium/chromium/src/+/master:v8/src/interpreter/interpreter-generator.cc;drc=6cdb24a4ce9d4151035c1f133833137d2e2881d1;l=1467">此处</a>查看。本质上，它是对依赖于架构（architecture-dependent）的内置 <a href="https://source.chromium.org/chromium/chromium/src/+/master:v8/src/builtins/x64/builtins-x64.cc;drc=8665f09771c6b8220d6020fe9b1ad60a4b0b6591;l=1277"><code>InterpreterPushArgsThenCall</code></a> 的尾调用。<p>内置函数实际上将返回地址（return address）弹出到临时寄存器中，推入所有参数（包括接收者（receiver）），然后推回返回地址。在这一点上，我们不知道被调用者是否是可调用对象，也不知道被调用者期望多少个参数，即它的形式参数数量。<figure><img alt="" height=191 loading=lazy src=/_img/adaptor-frame/normal-push.svg width=422><figcaption>内置 <code>InterpreterPushArgsThenCall</code> 执行后的帧状态。</figcaption></figure><p>最终，对内置 <a href="https://source.chromium.org/chromium/chromium/src/+/master:v8/src/builtins/x64/builtins-x64.cc;drc=8665f09771c6b8220d6020fe9b1ad60a4b0b6591;l=2256"><code>Call</code></a> 执行尾调用。在那里，它检查目标是否是适当的函数，构造函数或任何可调用对象。它还读取 <code>shared function info</code> 结构以获取其形式参数数量。<p>如果被调用者（callee）是一个函数对象，它将对内置的 <a href="https://source.chromium.org/chromium/chromium/src/+/master:v8/src/builtins/x64/builtins-x64.cc;drc=8665f09771c6b8220d6020fe9b1ad60a4b0b6591;l=2038"><code>CallFunction</code></a> 进行尾调用，在其中进行一堆检查，包括是否有 <code>undefined</code> 的对象作为接收者。 如果我们有一个 <code>undefined</code> 或 <code>null</code> 的对象作为接收者，则应根据 <a href=https://262.ecma-international.org/11.0/#sec-ordinarycallbindthis>ECMA 规范</a>对其进行修正，以引用全局代理对象。<p>然后执行对内置 <a href="https://source.chromium.org/chromium/chromium/src/+/master:v8/src/codegen/x64/macro-assembler-x64.cc;drc=a723767935dec385818d1134ea729a4c3a3ddcfb;l=2781"><code>InvokeFunctionCode</code></a> 的尾调用，在没有参数不匹配的情况下，InvokeFunctionCode 将仅调用被调用对象（callee object）中字段 <code>Code</code> 所指向的内容。这可以是优化的函数，也可以是内置的 <a href="https://source.chromium.org/chromium/chromium/src/+/master:v8/src/builtins/x64/builtins-x64.cc;drc=8665f09771c6b8220d6020fe9b1ad60a4b0b6591;l=1037"><code>InterpreterEntryTrampoline</code></a>。<p>如果我们假设要调用的函数尚未进行优化，则 Ignition trampoline 将设置一个 <code>IntepreterFrame</code>。你可以在<a href="https://source.chromium.org/chromium/chromium/src/+/master:v8/src/execution/frame-constants.h;drc=574ac5d62686c3de8d782dc798337ce1355dc066;l=14">此处</a>查看 V8 中帧类型的简短摘要。<p>无需过多讨论接下来发生的事情细节，我们可以在被调用者（callee）执行期间看到解释器帧（interpreter frame）的快照。<figure><img alt="" height=511 loading=lazy src=/_img/adaptor-frame/normal-frame.svg width=588><figcaption>调用 <code>add42(3)</code> 的 <code>InterpreterFrame</code>。</figcaption></figure><p>我们看到帧中有固定数量的插槽（slots）：返回地址（return address），前一个帧指针（previous frame pointer），上下文（context），我们正在执行的当前函数对象，该函数的字节码数组（bytecode array）以及我们当前正在执行的字节码的偏移量（bytecode offset）。最后，我们有一个专用于此函数的寄存器列表（你可以将它们视为函数局部变量）。<code>add42</code> 函数实际上没有任何寄存器，但调用者（caller）具有类似的帧，其中包含 3 个寄存器。<p>如预期的那样，add42 是一个简单的函数：<pre><code>25 02             Ldar a0          ;; Load the first argument to the accumulator
40 2a 00          AddSmi [42]      ;; Add 42 to it
ab                Return           ;; Return the accumulator
</code></pre><p>请注意我们如何在 <code>Ldar</code><em>（Load Accumulator Register，负载累加器寄存器）</em> 字节码中对参数进行编码：参数 <code>1</code>（<code>a0</code>）的编码为数字 <code>02</code>。实际上，任何参数的编码都是 <code>[ai] = 2 + parameter_count - i - 1</code>，接收者（receiver）的编码都是 <code>[this] = 2 + parameter_count</code>，或者说在本例中为 <code>[this] = 3</code>。此处的参数数量不包括接收者。<p>现在，我们能够理解为什么我们用这种方式对寄存器和参数进行编码。它们只是表示与帧指针（frame pointer）的偏移量。然后，我们可以用相同的方式理解参数/寄存器的加载和存储。帧指针的最后一个参数的偏移量为 <code>2</code>（先前的帧指针和返回地址）。这就解释了编码中的 <code>2</code>。 解释器帧（interpreter frame）的固定部分是 <code>6</code> 个插槽（距帧指针 <code>4</code> 个），因此寄存器零位于偏移量 <code>-5</code> 处，即 <code>fb</code>，寄存器 <code>1</code> 位于 <code>fa</code> 处。聪明吧？<p>但是请注意，为了能够访问参数，该函数必须知道堆栈中有多少个参数！ 索引 <code>2</code> 指向最后一个参数，而不管有多少个参数！<p><code>Return</code> 的字节码处理程序将通过调用内置的 <code>LeaveInterpreterFrame</code> 来完成。该内置函数本质上是从帧中读取函数对象以获取参数数量，弹出当前帧，恢复帧指针（frame pointer），将返回地址保存在暂存器（scratch register）中，根据参数数量弹出参数并跳转到暂存器中的地址。<p>所有这一切都很棒！但是，当我们调用一个带有少于或多于其参数数量的参数的函数时，会发生什么呢？聪明的参数/寄存器访问将失败，并且如何在调用结束时清理参数？<h2 id=arguments-adaptor-frame>Arguments adaptor frame <a href=#arguments-adaptor-frame class=bookmark>#</a></h2><p>现在，使用更少和更多的参数调用 <code>add42</code>：<pre class=language-js><code class=language-js><span class="token function">add42</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">add42</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>我们 JS 开发人员将知道，在第一种情况下，<code>x</code> 将被赋值为 <code>undefined</code>，并且该函数将返回 <code>undefined + 42 = NaN</code>。在第二种情况下，<code>x</code> 将被分配为 <code>1</code>，函数将返回 <code>43</code>，其余参数将被忽略。请注意，调用者（caller）不知道是否会发生这种情况。即使调用者检查了参数数量，被调用者（callee）也可以使用剩余（rest）参数或 arguments 对象访问所有其他参数。 实际上，在非严格模式（sloppy mode）下甚至可以在 <code>add42</code> 外部访问 arguments 对象。<p>如果我们执行与之前相同的步骤，则将首先调用内置的 <code>InterpreterPushArgsThenCall</code>。它会将参数推入堆栈，如下所示：<figure><img alt="" height=276 loading=lazy src=/_img/adaptor-frame/adaptor-push.svg width=679><figcaption>内置 <code>InterpreterPushArgsThenCall</code> 执行后的帧状态。</figcaption></figure><p>继续与之前相同的过程，我们检查被调用者（callee）是否为函数对象，获取其参数数量，并将接收者修正到全局代理（global proxy）。最终，我们到达了 <code>InvokeFunctionCode</code> 。<p>在这里，而不是跳转到被调用者（callee）对象中的 <code>Code</code>。我们检查参数个数（argument size）和参数数量之间是否不匹配，然后跳转到 <code>ArgumentsAdaptorTrampoline</code>。<p>在此内置函数中，我们构建了一个额外的帧，即臭名昭著的 arguments adaptor frame。在不解释内置函数内部实现的情况下，我将向你介绍内置函数调用被调用者的 <code>Code</code> 之前的帧状态。请注意，这是一个恰当的 <code>x64 调用</code>（不是 <code>jmp</code>），在执行被调用者之后，我们将返回到 <code>ArgumentsAdaptorTrampoline</code>。这与尾调用的 <code>InvokeFunctionCode</code> 形成对比。<figure><img alt="" height=665 loading=lazy src=/_img/adaptor-frame/adaptor-frames.svg width=767><figcaption>带有参数自适应（arguments adaptation）的堆栈帧（Stack frames）。</figcaption></figure><p>你可以看到，我们创建了另一个帧，该帧复制了所有必需的参数，以使 arguments 的参数数量精确地位于被调用者帧（callee frame）的顶部。它创建了被调用者（callee）函数的接口，因此后者无需知道参数的数量。被调用者（callee）将始终能够使用与以前相同的计算来访问其参数，即 <code>[ai] = 2 + parameter_count - i - 1</code>。<p>V8 具有特殊的内置函数，它们在需要通过剩余（rest）参数或 arguments 对象访问其余参数时就了解适配器帧（adaptor frame）。它们将始终需要检查被调用者帧（callee’s frame）上方的适配器帧类型（adaptor frame type），然后采取相应措施。<p>如你所见，我们解决了参数/寄存器访问问题，但是却造成了很多复杂性。每个需要访问所有参数的内置函数都需要了解并检查适配器帧（adaptor frame）的存在。不仅如此，我们还需要注意不要访问陈旧的旧数据。考虑对 <code>add42</code> 的以下更改：<pre class=language-js><code class=language-js><span class="token keyword">function</span> <span class="token function">add42</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  x <span class="token operator">+=</span> <span class="token number">42</span><span class="token punctuation">;</span><br>  <span class="token keyword">return</span> x<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>现在，字节码数组为：<pre><code>25 02             Ldar a0       ;; Load the first argument to the accumulator
40 2a 00          AddSmi [42]   ;; Add 42 to it
26 02             Star a0       ;; Store accumulator in the first argument slot
ab                Return        ;; Return the accumulator
</code></pre><p>如你所见，我们现在修改 <code>a0</code>。因此，在调用 <code>add42(1, 2, 3)</code> 的情况下，arguments adaptor frame 中的插槽（slot）将被修改，但调用者帧（caller frame）仍将包含数字 <code>1</code>。我们需要注意，参数对象正在访问修改后的值，而不是陈旧的值。<p>从函数返回很简单，尽管很慢。还记得 <code>LeaveInterpreterFrame</code> 做什么吗？它基本上会弹出被调用者帧（callee frame）和逐个弹出参数直到参数个数的数量为止。因此，当我们返回 arguments adaptor stub 时，堆栈如下所示：<figure><img alt="" height=401 loading=lazy src=/_img/adaptor-frame/adaptor-frames-cleanup.svg width=765><figcaption><code>add42</code>执行被调用者（callee）之后的帧状态。State of the frames after the execution of the callee <code>add42</code>.</figcaption></figure><p>我们只需要弹出参数数量，弹出 adaptor frame，根据实际参数数量弹出所有参数，然后返回到调用者（caller）执行即可。<p>TL;DR: arguments adaptor 机制不仅复杂，而且成本很高。<h2 id=removing-the-arguments-adaptor-frame>移除 arguments adaptor frame <a href=#removing-the-arguments-adaptor-frame class=bookmark>#</a></h2><p>我们可以做得更好吗？我们可以移除 adaptor frame 吗？ 事实证明，我们确实可以。<p>让我们回顾一下我们的要求：<ol><li>我们需要能够像以前一样无缝访问参数和寄存器。访问它们时不进行检查。因为那样的成本太昂贵了。<li>我们需要能够从堆栈中构造剩余（rest）参数和 arguments 对象。<li>从调用返回时，我们需要能够轻松清理未知数量的参数。<li>而且，当然我们希望没有额外的帧！</ol><p>如果要消除多余的帧，则需要确定将参数放在哪里：在被调用者帧（callee frame）中还是在调用者帧（caller frame）中。<h3 id=arguments-in-the-callee-frame>Arguments 在 callee frame 中 <a href=#arguments-in-the-callee-frame class=bookmark>#</a></h3><p>假设我们将参数（arguments）放在被调用者帧（callee frame）中。这实际上似乎是一个好主意，因为无论何时弹出帧，我们也会立即弹出所有参数！<p>参数必须位于保存的帧指针（frame pointer）和帧末尾之间的某个位置。这就要求帧的大小不会被静态地知道。访问参数仍然很容易，这是与帧指针的简单偏移量。但是现在访问寄存器要复杂得多，因为它根据参数的数量而有所不同。<p>堆栈指针（stack pointer）始终指向最后一个寄存器（register），然后我们可以使用它来访问寄存器而无需知道参数数。这种方法实际上可能有效，但是它有一个主要缺点。那将需要复制所有可以访问寄存器和参数的字节码。我们需要一个 <code>LdaArgument</code> 和一个 <code>LdaRegister</code> 来代替 <code>Ldar</code>。当然，我们还可以检查是否正在访问参数或寄存器（正或负偏移量），但这将需要检查每个参数并进行寄存器访问。显然成本太昂贵了！<h3 id=arguments-in-the-caller-frame>Arguments in the caller frame <a href=#arguments-in-the-caller-frame class=bookmark>#</a></h3><p>好吧……如果我们坚持将参数（arguments）放在调用者帧（caller frame）中，该怎么办？<p>记住如何计算一帧中参数 <code>i</code> 的偏移量：<code>[ai] = 2 + parameter_count - i - 1</code>。如果我们拥有所有 arguments（不仅是 parameters），则偏移量将为 <code>[ai] = 2 + argument_count - i - 1</code>。也就是说，对于每次参数（argument）访问，我们都需要加载实际的参数计数（argument count）。<p>但是，如果我们颠倒参数的顺序会发生什么呢？现在可以简单地将偏移量计算为 <code>[ai] = 2 + i</code>。我们不需要知道堆栈中有多少个参数，但是如果我们可以保证至少在堆栈中至少有参数个数（parameter count of arguments），那么我们就可以始终使用此方案来计算偏移量。<p>换句话说，压入堆栈的参数数量将始终是参数数量（number of arguments）与形式参数数量（formal parameter count）之间的最大值，并且在需要时将使用 undefined 对象进行填充。<p>这还有另一个好处！对于任何 JS 函数，接收者（receiver）始终位于相同的偏移量处，位于返回地址（return address）的正上方：<code>[this] = 2</code>。<p>对于我们的第 <code>1</code> 号和第 <code>4</code> 号要求，这是一个干净的解决方案。其他两个要求又如何呢？我们如何构造剩余（rest）参数和 arguments 对象？返回调用者（caller）时如何清理堆栈中的参数？为此，我们仅缺少参数计数（argument count）。我们需要将其保存在某个地方。只要可以轻松访问此信息，此处的选择就有些随意。有两个基本选择：将其推入到调用者帧（caller frame）中的接收者（receiver）之后，或作为固定标头（fixed header）部分中的被呼叫者帧（callee frame）的一部分。我们实现了后者，因为它合并了 Interpreter 和 Optimized frames 的固定标头部分。<p>如果在 V8 v8.9 中运行示例，则在 <code>InterpreterArgsThenPush</code> 之后将看到以下堆栈（请注意，现在参数已颠倒）：<figure><img alt="" height=276 loading=lazy src=/_img/adaptor-frame/no-adaptor-push.svg width=679><figcaption>内置 <code>InterpreterPushArgsThenCall</code> 执行后的帧状态。</figcaption></figure><p>所有执行都遵循相似的路径，直到我们到达 InvokeFunctionCode。在这里，我们在 under-application 情况下处理参数，根据需要推送尽可能多的 undefined 对象。请注意，在 over-application 情况下，我们不会进行任何更改。最后，我们通过寄存器将参数数量（number of arguments）传递给被调用者（callee）的 <code>Code</code>。 在 <code>x64</code> 的情况下，我们使用寄存器 <code>rax</code>。<p>如果被调用者（callee）尚未进行优化，我们将到达 <code>InterpreterEntryTrampoline</code>，它会构建以下堆栈帧（stack frame）。<figure><img alt="" height=626 loading=lazy src=/_img/adaptor-frame/no-adaptor-frames.svg width=679><figcaption>没有 arguments adaptors 的堆栈帧（Stack frames）。</figcaption></figure><p>被调用者帧（callee frame）有一个额外的插槽（slot），其中包含可用于构造剩余（rest）参数或 arguments 对象的参数数量（number of arguments），并可以在返回调用者（caller）之前清除堆栈中的参数。<p>作为返回，我们修改 <code>LeaveInterpreterFrame</code> 以读取堆栈中的参数计数（arguments count），并弹出参数计数（argument count）和形式参数计数（formal parameter count）之间的最大数目。<h2 id=turbofan>TurboFan <a href=#turbofan class=bookmark>#</a></h2><p>那么优化代码呢？让我们稍微更改一下初始脚本，以强制 V8 使用 TurboFan 对其进行编译：<pre class=language-js><code class=language-js><span class="token keyword">function</span> <span class="token function">add42</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><br><span class="token keyword">function</span> <span class="token function">callAdd42</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">add42</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><br><span class="token operator">%</span><span class="token function">PrepareFunctionForOptimization</span><span class="token punctuation">(</span>callAdd42<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">callAdd42</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token operator">%</span><span class="token function">OptimizeFunctionOnNextCall</span><span class="token punctuation">(</span>callAdd42<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">callAdd42</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在这里，我们使用 V8 内部机制（intrinsics）来强制 V8 优化调用，否则 V8 仅在我们的小函数变得热门（经常使用）时才对其进行优化。在优化之前，我们将其称为一次（once），以收集一些可用于指导编译的类型信息。在<a href=https://v8.dev/docs/turbofan>此处</a>阅读有关 TurboFan 的更多信息。<p>在这里，我仅向你显示与我们相关的部分生成代码。<pre class=language-nasm><code class=language-nasm>movq <span class="token register variable">rdi</span>,<span class="token number">0x1a8e082126ad</span>    <span class="token comment">;; Load the function object &lt;JSFunction add42></span><br>push <span class="token number">0x6</span>                   <span class="token comment">;; Push SMI 3 as argument</span><br>movq <span class="token register variable">rcx</span>,<span class="token number">0x1a8e082030d1</span>    <span class="token comment">;; &lt;JSGlobal Object></span><br>push <span class="token register variable">rcx</span>                   <span class="token comment">;; Push receiver (the global proxy object)</span><br>movl <span class="token register variable">rax</span>,<span class="token number">0x1</span>               <span class="token comment">;; Save the arguments count in rax</span><br>movl <span class="token register variable">rcx</span>,<span class="token operator">[</span><span class="token register variable">rdi</span><span class="token operator">+</span><span class="token number">0x17</span><span class="token operator">]</span>        <span class="token comment">;; Load function object {Code} field in rcx</span><br>call <span class="token register variable">rcx</span>                   <span class="token comment">;; Finally, call the code object!</span></code></pre><p>尽管使用汇编程序编写，但是如果你参考我的注释，那么此代码段应该不难理解。本质上，在编译调用时，TF需要完成 <code>InterpreterPushArgsThenCall</code>，<code>Call</code>，<code>CallFunction</code> 和 <code>InvokeFunctionCall</code> 内置函数中的所有工作。希望它有更多的静态信息来执行此操作，并发出更少的计算机指令。<h3 id=turbofan-with-the-arguments-adaptor-frame>带 arguments adaptor frame 的 TurboFan <a href=#turbofan-with-the-arguments-adaptor-frame class=bookmark>#</a></h3><p>现在，让我们来看看参数数量（number of arguments）和参数计数（parameter count）不匹配的情况。考虑调用 <code>add42(1, 2, 3)</code>。编译为：<pre class=language-nasm><code class=language-nasm>movq <span class="token register variable">rdi</span>,<span class="token number">0x4250820fff1</span>    <span class="token comment">;; Load the function object &lt;JSFunction add42></span><br><span class="token comment">;; Push receiver and arguments SMIs 1, 2 and 3</span><br>movq <span class="token register variable">rcx</span>,<span class="token number">0x42508080dd5</span>    <span class="token comment">;; &lt;JSGlobal Object></span><br>push <span class="token register variable">rcx</span><br>push <span class="token number">0x2</span><br>push <span class="token number">0x4</span><br>push <span class="token number">0x6</span><br>movl <span class="token register variable">rax</span>,<span class="token number">0x3</span>              <span class="token comment">;; Save the arguments count in rax</span><br>movl <span class="token register variable">rbx</span>,<span class="token number">0x1</span>              <span class="token comment">;; Save the formal parameters count in rbx</span><br>movq <span class="token register variable">r10</span>,<span class="token number">0x564ed7fdf840</span>   <span class="token comment">;; &lt;ArgumentsAdaptorTrampoline></span><br>call <span class="token register variable">r10</span>                  <span class="token comment">;; Call the ArgumentsAdaptorTrampoline</span></code></pre><p>如你所见，不难为 TF 添加对参数（argument）和参数计数（parameter count）不匹配的支持。只需调用 arguments adaptor trampoline！<p>然而，这是昂贵的。对于每个优化的调用，我们现在都需要输入 arguments adaptor trampoline，并像未优化的代码一样对帧进行处理。这就解释了为什么在优化的代码中删除 adaptor frame 的性能收益比在 Ignition 上要大得多。<p>但是，生成的代码非常简单。从中返回非常容易（结尾）：<pre class=language-nasm><code class=language-nasm>movq <span class="token register variable">rsp</span>,<span class="token register variable">rbp</span>   <span class="token comment">;; Clean callee frame</span><br>pop <span class="token register variable">rbp</span><br>ret <span class="token number">0x8</span>        <span class="token comment">;; Pops a single argument (the receiver)</span></code></pre><p>我们弹出帧，并根据参数计数（parameter count）发出返回指令。如果我们在参数数量（number of arguments）和参数计数（parameter count）上不匹配，则 adaptor frame trampoline 将对其进行处理。<h3 id=turbofan-without-the-arguments-adaptor-frame>没有 arguments adaptor frame 的 TurboFan <a href=#turbofan-without-the-arguments-adaptor-frame class=bookmark>#</a></h3><p>生成的代码本质上与参数数量（number of arguments）匹配的调用中的代码相同。考虑调用 <code>add42(1, 2, 3)</code>。这将生成：<pre class=language-nasm><code class=language-nasm>movq <span class="token register variable">rdi</span>,<span class="token number">0x35ac082126ad</span>    <span class="token comment">;; Load the function object &lt;JSFunction add42></span><br><span class="token comment">;; Push receiver and arguments 1, 2 and 3 (reversed)</span><br>push <span class="token number">0x6</span><br>push <span class="token number">0x4</span><br>push <span class="token number">0x2</span><br>movq <span class="token register variable">rcx</span>,<span class="token number">0x35ac082030d1</span>    <span class="token comment">;; &lt;JSGlobal Object></span><br>push <span class="token register variable">rcx</span><br>movl <span class="token register variable">rax</span>,<span class="token number">0x3</span>               <span class="token comment">;; Save the arguments count in rax</span><br>movl <span class="token register variable">rcx</span>,<span class="token operator">[</span><span class="token register variable">rdi</span><span class="token operator">+</span><span class="token number">0x17</span><span class="token operator">]</span>        <span class="token comment">;; Load function object {Code} field in rcx</span><br>call <span class="token register variable">rcx</span>                   <span class="token comment">;; Finally, call the code object!</span></code></pre><p>该函数的结尾如何？我们不再返回到 rguments adaptor trampoline，因此结尾确实比以前复杂了一些。<pre class=language-nasm><code class=language-nasm>movq <span class="token register variable">rcx</span>,<span class="token operator">[</span><span class="token register variable">rbp</span><span class="token operator">-</span><span class="token number">0x18</span><span class="token operator">]</span>        <span class="token comment">;; Load the argument count (from callee frame) to rcx</span><br>movq <span class="token register variable">rsp</span>,<span class="token register variable">rbp</span>               <span class="token comment">;; Pop out callee frame</span><br>pop <span class="token register variable">rbp</span><br>cmpq <span class="token register variable">rcx</span>,<span class="token number">0x0</span>               <span class="token comment">;; Compare arguments count with formal parameter count</span><br>jg <span class="token number">0x35ac000840c6</span>  <span class="token operator">&lt;</span><span class="token operator">+</span><span class="token number">0x86</span><span class="token operator">></span><br><span class="token comment">;; If arguments count is smaller (or equal) than the formal parameter count:</span><br>ret <span class="token number">0x8</span>                    <span class="token comment">;; Return as usual (parameter count is statically known)</span><br><span class="token comment">;; If we have more arguments in the stack than formal parameters:</span><br>pop <span class="token register variable">r10</span>                    <span class="token comment">;; Save the return address</span><br>leaq <span class="token register variable">rsp</span>,<span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">+</span><span class="token register variable">rcx</span><span class="token operator">*</span><span class="token number">8</span><span class="token operator">+</span><span class="token number">0x8</span><span class="token operator">]</span>   <span class="token comment">;; Pop all arguments according to rcx</span><br>push <span class="token register variable">r10</span>                   <span class="token comment">;; Recover the return address</span><br>retl</code></pre><h1 id=%E7%BB%93%E8%AE%BA>结论 <a href=#%E7%BB%93%E8%AE%BA class=bookmark>#</a></h1><p>Arguments adaptor frame 是一个临时解决方案，用于参数（arguments）和形式参数（formal parameters）数量不匹配的调用。这是一个简单的解决方案，但它带来了很高的性能成本，并增加了代码库的复杂性。如今，许多 Web 框架使用此功能创建更灵活的 API 都会加剧性能成本。颠倒堆栈中参数顺序的简单想法可以大大降低实现复杂性，并消除了此类调用的几乎所有开销。</div><footer><div><picture><source srcset="/_img/avatars/victor-gomes.avif, /_img/avatars/victor-gomes@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/victor-gomes.jpg width=96 srcset="/_img/avatars/victor-gomes@2x.jpg 2x"></picture><p>作者：<a href=https://twitter.com/VictorBFG>Victor Gomes</a>, the frame shredder.</div><a href=https://twitter.com/v8js/status/1361337569057865735 class=retweet>Retweet this article!</a></footer><footer><div><p>译者：不如怀念 (<a href=https://github.com/wang1212>@wang1212</a>).</div></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/adaptor-frame>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/adaptor-frame.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>