<!doctype html><html lang=zh-CN><meta charset=utf-8><title>Oilpan library · V8</title><meta content="width=device-width" name=viewport><meta content="dark light" name=color-scheme><link href=/_css/main.css rel=stylesheet><link href=/.webmanifest rel=manifest><meta content=#4285F4 name=theme-color><link href=/blog.atom rel=alternate title="V8 Atom feed" type=application/atom+xml><link href=/features.atom rel=alternate title="V8 JS/Wasm features Atom feed" type=application/atom+xml><script>document.documentElement.className+=" js"</script><meta content="V8 ships with Oilpan, a garbage collection library for hosting managed C++ memory." name=description><header id=header><h1><a href=/ >V8</a></h1><a href=#navigation-toggle id=nav-toggle>显示导肮</a><nav><ul><li><a href=/ >主页</a><li class=active><a href=/blog/ >博客</a><li><a href=/docs/ >文档</a><li><a href=/tools/ >工具</a><li><a href=/features title="JavaScript 和 WebAssembly 的新特性">JS/Wasm 新特性</a><li><a href=/grant>Research</a></ul></nav></header><main id=main><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>Oilpan library</h1><p class=meta>发布时间 <time datetime="2021-11-10 00:00:00" itemprop=datePublished title="2021-11-10 00:00:00">2021-11-10</time> · 标签： <a href=/blog/tags/internals/ class=tag>internals</a> <a href=/blog/tags/memory/ class=tag>memory</a> <a href=/blog/tags/cppgc/ class=tag>cppgc</a></header><div itemprop=articleBody><p>While the title of this post may suggest taking a deep dive into a collection of books around oil pans – which, considering construction norms for pans, is a topic with a surprising amount of literature – we are instead looking a bit closer at Oilpan, a C++ garbage collector that is hosted through V8 as a library since V8 v9.4.<p>Oilpan is a <a href=https://en.wikipedia.org/wiki/Tracing_garbage_collection>trace-based garbage collector</a>, meaning that it determines live objects by traversing an object graph in a marking phase. Dead objects are then reclaimed in a sweeping phase, which we have <a href=https://v8.dev/blog/high-performance-cpp-gc>blogged about in the past</a>. Both phases may run interleaved or parallel to actual C++ application code. Reference handling for heap objects is precise, and conservative for the native stack. This means that Oilpan knows where references are on the heap but has to scan the memory assuming random bit sequences represent pointers for the stack. Oilpan also supports compaction (defragmenting the heap) for certain objects when garbage collection runs without a native stack.<p>So, what’s the deal with providing it as a library through V8?<p>Blink, being forked from WebKit, originally used reference counting, a <a href=https://en.cppreference.com/w/cpp/memory/shared_ptr>well-known paradigm for C++ code</a>, for managing its on-heap memory. Reference counting is supposed to solve memory management issues but is known to be prone to memory leaks due to cycles. On top of this inherent problem, Blink also suffered from <a href=https://en.wikipedia.org/wiki/Dangling_pointer>use-after-free issues</a> as sometimes reference counting would be omitted for performance reasons. Oilpan was initially developed specifically for Blink to simplify the programming model and get rid of memory leaks and use-after-free issues. We believe Oilpan succeeded in simplifying the model and also in making the code more secure.<p>Another maybe less pronounced reason for introducing Oilpan in Blink was to aid integration into other garbage collected systems such as V8 which eventually materialized in implementing the <a href=https://v8.dev/blog/tracing-js-dom>unified JavaScript and C++ heap</a> where Oilpan takes care of processing C++ objects. With more and more object hierarchies being managed and better integration with V8, Oilpan became increasingly complex over time and the team realized that they were reinventing the same concepts as in V8’s garbage collector and solving the same problems. Integration in Blink required building around 30k targets to actually run a hello world garbage collection test for unified heap.<p>Early 2020, we started a journey in carving out Oilpan from Blink and encapsulating it into a library. We decided to host the code in V8, reuse abstractions where possible, and do some spring cleaning on the garbage collection interface. In addition to fixing all of the aforementioned issues, <a href=https://docs.google.com/document/d/1ylZ25WF82emOwmi_Pg-uU6BI1A-mIbX_MG9V87OFRD8/ >a library</a> would also enable other projects to make use of garbage-collected C++. We launched the library in V8 v9.4 and enabled it in Blink starting in Chromium M94.<h2 id=what%E2%80%99s-in-the-box%3F>What’s in the box? <a href=#what%E2%80%99s-in-the-box%3F class=bookmark>#</a></h2><p>Similar to the rest of V8, Oilpan now provides a <a href=https://chromium.googlesource.com/v8/v8.git/+/HEAD/include/cppgc/ >stable API</a> and embedders may rely on the regular <a href=https://v8.dev/docs/api>V8 conventions</a>. For example, this means that APIs are properly documented (see <a href=https://chromium.googlesource.com/v8/v8.git/+/main/include/cppgc/garbage-collected.h#17>GarbageCollected</a>) and will go through a deprecation period in case they are subject to being removed or changed.<p>The core of Oilpan is available as a stand-alone C++ garbage collector in the <code>cppgc</code> namespace. The setup also allows for reusing an existing V8 platform to create a heap for managed C++ objects. Garbage collections can be configured to run automatically, integrating in the task infrastructure or can be triggered explicitly considering the native stack as well. The idea is to allow embedders that just want managed C++ objects to avoid dealing with V8 as a whole, see this <a href=https://chromium.googlesource.com/v8/v8.git/+/main/samples/cppgc/hello-world.cc>hello world program</a> as an example. An embedder of this configuration is PDFium which uses Oilpan’s stand-alone version for <a href="https://groups.google.com/a/chromium.org/g/chromium-dev/c/RAqBXZWsADo/m/9NH0uGqCAAAJ?utm_medium=email&utm_source=footer">securing XFA</a> which allows for more dynamic PDF content.<p>Conveniently, tests for the core of Oilpan use this setup which means that it’s a matter of seconds to build and run a specific garbage collection test. As of today, <a href=https://source.chromium.org/chromium/chromium/src/+/main:v8/test/unittests/heap/cppgc/ >>400 of such unit tests</a> for the core of Oilpan exist. The setup also serves as a playground to experiment and try out new things and may be used to validate assumptions around raw performance.<p>Oilpan library also takes care of processing C++ objects when running with the unified heap through V8 which allows full tangling of C++ and JavaScript object graphs. This configuration is used in Blink for managing the C++ memory of the DOM and more. Oilpan also exposes a trait system that allows for extending the core of the garbage collector with types that have very specific needs for determining liveness. This way it is possible for Blink to provide its own collection libraries that even allow building JavaScript-style ephemeron maps (<a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap><code>WeakMap</code></a>) in C++. We don’t recommend this to everyone but it shows what this system is capable of in case there’s a need for customization.<h2 id=where-are-we-headed%3F>Where are we headed? <a href=#where-are-we-headed%3F class=bookmark>#</a></h2><p>Oilpan library provides us with a solid foundation that we can now leverage to improve performance. Where we would previously need to specify garbage collection specific functionality on V8’s public API to interact with Oilpan, we can now directly implement what we need. This allows for fast iteration and also taking shortcuts and improving performance where possible.<p>We also see potential in providing certain basic containers directly through Oilpan to avoid reinventing the wheel. This would allow other embedders to benefit from data structures that were previously created specifically for Blink.<p>Seeing a bright future for Oilpan, we would like to mention that the existing <a href="https://source.chromium.org/chromium/chromium/src/+/main:v8/include/v8-embedder-heap.h;l=75"><code>EmbedderHeapTracer</code></a> APIs are not going to be further improved and may be deprecated at some point. Assuming embedders making use of such APIs already implemented their own tracing system, migrating to Oilpan should be as simple as just allocating the C++ objects on a newly created <a href="https://source.chromium.org/chromium/chromium/src/+/main:v8/include/v8-cppgc.h;l=91">Oilpan heap</a> that is then attached to a V8 Isolate. Existing infrastructure for modeling references such as <a href="https://source.chromium.org/chromium/chromium/src/+/main:v8/include/v8-traced-handle.h;l=334"><code>TracedReference</code></a> (for references into V8) and <a href="https://source.chromium.org/chromium/chromium/src/+/main:v8/include/v8-object.h;l=502">internal fields</a> (for references outgoing from V8) are supported by Oilpan.<p>Stay tuned for more garbage collection improvements in the future!<p>Encountering issues, or have suggestions? Let us know:<ul><li><a href=mailto:oilpan-dev@chromium.org>oilpan-dev@chromium.org</a><li>Monorail: <a href="https://bugs.chromium.org/p/chromium/issues/entry?template=Defect+report+from+user&components=Blink%3EGarbageCollection">Blink>GarbageCollection</a> (Chromium), <a href="https://bugs.chromium.org/p/v8/issues/entry?template=Defect+report+from+user&components=Oilpan">Oilpan</a> (V8)</ul></div><footer><div><picture><source srcset="/_img/avatars/anton-bikineev.avif, /_img/avatars/anton-bikineev@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/anton-bikineev.jpg srcset="/_img/avatars/anton-bikineev@2x.jpg 2x" width=96></picture><picture><source srcset="/_img/avatars/omer-katz.avif, /_img/avatars/omer-katz@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/omer-katz.jpg srcset="/_img/avatars/omer-katz@2x.jpg 2x" width=96></picture><picture><source srcset="/_img/avatars/michael-lippautz.avif, /_img/avatars/michael-lippautz@2x.avif 2x" type=image/avif><img alt="" height=96 loading=lazy src=/_img/avatars/michael-lippautz.jpg srcset="/_img/avatars/michael-lippautz@2x.jpg 2x" width=96></picture><p>作者：Anton Bikineev, Omer Katz (<a href=https://twitter.com/omerktz>@omerktz</a>), and Michael Lippautz (<a href=https://twitter.com/mlippautz>@mlippautz</a>), efficient and effective file movers.</div><a href=https://twitter.com/v8js/status/1458406645181165574 class=retweet>Retweet this article!</a></footer></article></main><footer id=footer><div><nav><a href=https://v8.dev/blog/oilpan-library>原文</a> · <a href=/logo/ >商标</a> · <a href=/terms/ >条款</a> · <a href=https://policies.google.com/privacy/ >隐私</a> · <a href=https://twitter.com/v8js rel="me nofollow">Twitter</a> · <a href=https://github.com/justjavac/v8.js.cn/tree/master/./src/blog/oilpan-library.md rel=nofollow>在 GitHub 编辑此页面</a></nav><dark-mode-toggle dark="Light Theme" light="Dark Theme" permanent></dark-mode-toggle></div><p><small>如无特殊说明，此 V8 项目中使用到的所有示例代码均基于 <a href=https://chromium.googlesource.com/v8/v8.git/+/master/LICENSE>V8's BSD-style license</a> 发布。页面中的文字内容采用 <a href=https://creativecommons.org/licenses/by/3.0/ >the Creative Commons Attribution 3.0 License</a> 进行许可。更详细的信息可以在 <a href=/terms#site-policies>站点策略</a> 中找到。</small></footer><script src=/_js/dark-mode-toggle.mjs type=module></script><script src=/_js/main.mjs type=module></script><script src=/_js/legacy.js nomodule></script>